今天继续看看设计模式
为什么MVC不属于23种设计模式？
MVC其实是观察者模式，策略模式和组合模式的演变，而在MVC的框架中还会出现工厂模式和装饰器模式。
Model-->View-->Controller
Model表示应用的数据
View表示视图
Controller表示控制器，相当于胶水的作用，将Model和View粘合起来


代理模式：
当无法直接访问某个对象或者访问某个对象比较麻烦比较困难的时候，可以通过一个代理对象来间接访问，代理模式分为很多种，保护代理，虚拟代理，远程代理等等

开发过程中，客户端不想或者不能够直接访问一个对象，可以通过代理来实现间接的访问。
代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
         代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的
         内容和服务或者增添客户需要的额外的新服务。

代理模式包含三个角色：
    Subject：抽象主题角色
        声明了代理主题和真实主题的共同接口，这样一来任何使用真实主题的地方都可以使用代理主题，客户端通常针对抽象主题进行编程
    
    Proxy：代理主题角色
        它包含了对真实主题的引用，从而可以在任何时候操作真实主题，在代理主题中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题。
        代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，
        客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。
    
    RealSubject：真实主题角色
         它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作

1.抽象主题类声明了真实主题类和代理主题类的公共的方法
 abstract class Subject  {  
    public abstract void Request();  
}

2.真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：
class RealSubject extend Subject  {  
    public override void Request()  {  
        //业务方法具体实现代码  
    }  
}

3.代理主题类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法




























